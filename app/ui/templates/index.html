<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Trading Backtester</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        .chart-container {
            height: 600px;
            min-height: 500px;
            width: 100%;
        }
        @media (min-height: 800px) {
            .chart-container {
                height: 70vh;
                min-height: 600px;
            }
        }
        @media (min-height: 1000px) {
            .chart-container {
                height: 65vh;
                min-height: 650px;
            }
        }
        .metric-card {
            background-color: var(--bs-tertiary-bg);
            border-radius: .5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .metric-value {
            font-size: 1.75rem;
            font-weight: 500;
        }
        .metric-label {
            font-size: 0.9rem;
            color: var(--bs-secondary-color);
        }
        .table-responsive {
            max-height: 400px;
        }
        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--bs-body-bg);
            border-top: 1px solid var(--bs-border-color);
            padding: 0.5rem 1rem;
            z-index: 1000;
        }
        .nav-tabs .nav-link {
            color: var(--bs-secondary-color);
        }
        .nav-tabs .nav-link.active {
            color: var(--bs-primary);
        }
        .card-header-tabs {
            margin-bottom: -1px;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg bg-body-tertiary border-bottom">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">ðŸ“ˆ Grid Trading Backtester</a>
            <div id="ws-status" class="text-secondary">
                <span class="spinner-grow spinner-grow-sm text-secondary" role="status"></span>
                Connecting...
            </div>
        </div>
    </nav>

    <main class="container-fluid mt-4">
        <div class="row">
            <!-- Controls and Config -->
            <div class="col-lg-3">
                <h4>Controls</h4>
                <div class="card mb-4">
                    <div class="card-body">
                        <button id="run-backtest-btn" class="btn btn-primary w-100">Run Backtest</button>
                        <button id="cancel-backtest-btn" class="btn btn-danger w-100 mt-2" style="display: none;">Cancel Backtest</button>
                        <div id="progress-container" class="mt-3" style="display: none;">
                            <div class="progress" role="progressbar">
                                <div id="progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" style="width: 0%"></div>
                            </div>
                            <small id="progress-text" class="form-text text-muted"></small>
                        </div>
                    </div>
                </div>

                <h4>Configuration</h4>
                <div class="card mb-4">
                    <div class="card-body">
                        <h6 class="card-title">Chart Settings</h6>
                        <div class="mb-3">
                            <label for="dataPoints" class="form-label">Data Points</label>
                            <select class="form-select form-select-sm" id="dataPoints">
                                <option value="50">Last 50 points</option>
                                <option value="100">Last 100 points</option>
                                <option value="200" selected>Last 200 points</option>
                                <option value="500">Last 500 points</option>
                                <option value="all">All data</option>
                            </select>
                        </div>
                        <button class="btn btn-primary btn-sm w-100" id="updateChart">Update Chart</button>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-body">
                        <h6 class="card-title">Configuration Editor</h6>
                        <form id="config-form">
                            <div class="mb-3">
                                <label for="strategy-select" class="form-label fw-bold">Strategy</label>
                                <select id="strategy-select" class="form-select form-select-sm"></select>
                                <small id="strategy-config-path" class="form-text text-muted"></small>
                            </div>
                            <div id="config-fields"></div>
                            <button type="submit" class="btn btn-secondary w-100 mt-2" id="save-config-btn">Save Config</button>
                        </form>
                    </div>
                </div>
            </div>

            <!-- Results -->
            <div class="col-lg-9">
                <div id="results-container" style="display: none;">
                    <h4>Backtest Results (<span id="run-id-display"></span>)</h4>
                    <!-- Metrics -->
                    <div class="row">
                        <!-- Portfolio & Return Metrics -->
                        <div class="col-md-3"><div class="metric-card"><div id="metric-final-value" class="metric-value"></div><div class="metric-label">Final Portfolio Value</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-initial-capital" class="metric-value"></div><div class="metric-label">Initial Capital</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-peak-capital" class="metric-value"></div><div class="metric-label">Peak Capital</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-total-return" class="metric-value"></div><div class="metric-label">Total Return</div></div></div>
                        
                        <div class="col-md-3"><div class="metric-card"><div id="metric-return" class="metric-value"></div><div class="metric-label">Total Return %</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-annualized-return" class="metric-value"></div><div class="metric-label">Annualized Return %</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-max-drawdown" class="metric-value"></div><div class="metric-label">Max Drawdown %</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-max-drawdown-abs" class="metric-value"></div><div class="metric-label">Max Drawdown (â‚¹)</div></div></div>
                        
                        <!-- Risk Metrics -->
                        <div class="col-md-3"><div class="metric-card"><div id="metric-sharpe" class="metric-value"></div><div class="metric-label">Sharpe Ratio</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-sortino" class="metric-value"></div><div class="metric-label">Sortino Ratio</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-calmar" class="metric-value"></div><div class="metric-label">Calmar Ratio</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-volatility" class="metric-value"></div><div class="metric-label">Volatility %</div></div></div>
                        
                        <!-- Trading Metrics -->
                        <div class="col-md-3"><div class="metric-card"><div id="metric-trades" class="metric-value"></div><div class="metric-label">Total Trades</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-winning-trades" class="metric-value"></div><div class="metric-label">Winning Trades</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-losing-trades" class="metric-value"></div><div class="metric-label">Losing Trades</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-win-rate" class="metric-value"></div><div class="metric-label">Win Rate %</div></div></div>
                        
                        <div class="col-md-3"><div class="metric-card"><div id="metric-profit-factor" class="metric-value"></div><div class="metric-label">Profit Factor</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-avg-trade-pnl" class="metric-value"></div><div class="metric-label">Avg Trade P&L</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-avg-win-pnl" class="metric-value"></div><div class="metric-label">Avg Win P&L</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-avg-loss-pnl" class="metric-value"></div><div class="metric-label">Avg Loss P&L</div></div></div>
                        
                        <div class="col-md-3"><div class="metric-card"><div id="metric-largest-win" class="metric-value"></div><div class="metric-label">Largest Win</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-largest-loss" class="metric-value"></div><div class="metric-label">Largest Loss</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-max-consecutive-wins" class="metric-value"></div><div class="metric-label">Max Consecutive Wins</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-max-consecutive-losses" class="metric-value"></div><div class="metric-label">Max Consecutive Losses</div></div></div>
                        
                        <div class="col-md-3"><div class="metric-card"><div id="metric-avg-trade-duration" class="metric-value"></div><div class="metric-label">Avg Trade Duration (hrs)</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-total-fees" class="metric-value"></div><div class="metric-label">Total Fees</div></div></div>
                        
                        <!-- Tax Metrics -->
                        <div class="col-md-3"><div class="metric-card"><div id="metric-delivery-trades" class="metric-value"></div><div class="metric-label">Delivery Trades</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-intraday-trades" class="metric-value"></div><div class="metric-label">Intraday Trades</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-delivery-tax" class="metric-value"></div><div class="metric-label">Delivery Tax</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-intraday-tax" class="metric-value"></div><div class="metric-label">Intraday Tax</div></div></div>
                        <div class="col-md-3"><div class="metric-card"><div id="metric-total-tax" class="metric-value"></div><div class="metric-label">Total Tax Payable</div></div></div>
                    </div>

                    <!-- Charts -->
                    <div class="row">
                        <div class="col-12">
                            <div class="card">
                                <div class="card-header">
                                    <ul class="nav nav-tabs card-header-tabs" id="chart-tabs" role="tablist">
                                        <li class="nav-item" role="presentation">
                                            <button class="nav-link active" id="equity-tab" data-bs-toggle="tab" data-bs-target="#equity-pane" type="button" role="tab">Equity Curve</button>
                                        </li>
                                        <li class="nav-item" role="presentation">
                                            <button class="nav-link" id="candle-tab" data-bs-toggle="tab" data-bs-target="#candle-pane" type="button" role="tab">Candlestick Chart</button>
                                        </li>
                                    </ul>
                                </div>
                                <div class="card-body">
                                    <div class="tab-content" id="chart-tab-content">
                                        <div class="tab-pane fade show active" id="equity-pane" role="tabpanel">
                                            <div id="equity-chart" class="chart-container"></div>
                                        </div>
                                        <div class="tab-pane fade" id="candle-pane" role="tabpanel">
                                            <div id="candle-chart" class="chart-container"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Trades Table -->
                    <div class="row mt-4">
                        <div class="col-12">
                            <div class="card">
                                <div class="card-header">Order Executions</div>
                                <div class="card-body">
                                        <button id="export-csv-btn" class="btn btn-outline-success mb-3">Export Trades to CSV</button>
                                    <div class="table-responsive">
                                        <table class="table table-sm">
                                            <thead>
                                                <tr>
                                                    <th>Execution Time</th>
                                                    <th>Order Time</th>
                                                    <th>Side</th>
                                                    <th>Quantity</th>
                                                    <th>Requested</th>
                                                    <th>Executed</th>
                                                    <th>Fees</th>
                                                </tr>
                                            </thead>
                                            <tbody id="trades-table"></tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="welcome-message" class="text-center p-5">
                    <h3>Welcome to the Grid Trading Backtester</h3>
                    <p class="text-muted">Click "Run Backtest" to start a simulation.</p>
                </div>
            </div>
        </div>
    </main>

    <div id="status-bar">
        <span id="status-text">Ready.</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

        <script>
            document.addEventListener('DOMContentLoaded', function() {
                const exportBtn = document.getElementById('export-csv-btn');
                if (exportBtn) {
                    exportBtn.addEventListener('click', function() {
                        // Use the currentRunId variable to construct the export URL
                        let runId = null;
                        if (window.currentRunId) {
                            runId = window.currentRunId;
                        } else if (typeof currentRunId !== 'undefined' && currentRunId) {
                            runId = currentRunId;
                        } else {
                            runId = document.getElementById('run-id-display').textContent.trim();
                        }
                        if (runId) {
                            window.open(`/api/results/${runId}/export-csv`, '_blank');
                        } else {
                            alert('No backtest run ID found. Please run a backtest first.');
                        }
                    });
                }
            });
        </script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const wsStatus = document.getElementById('ws-status');
            const runBtn = document.getElementById('run-backtest-btn');
            const cancelBtn = document.getElementById('cancel-backtest-btn');
            const saveBtn = document.getElementById('save-config-btn');
            const configForm = document.getElementById('config-form');
            const configFields = document.getElementById('config-fields');
            const strategySelect = document.getElementById('strategy-select');
            const strategyConfigPath = document.getElementById('strategy-config-path');
            const statusBar = document.getElementById('status-text');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const resultsContainer = document.getElementById('results-container');
            const welcomeMessage = document.getElementById('welcome-message');

            let currentRunId = null;
            let currentResults = null; // Store current results for chart updates
            let loadedConfig = null;
            let availableStrategies = [];

            const STRATEGY_FIELDS = {
                grid: [
                    'grid_levels',
                    'grid_spacing_pct',
                    'order_amount',
                    'grid_type',
                    'auto_reset',
                    'initial_position_strategy',
                    'stop_loss_pct',
                    'take_profit_pct'
                ],
                supertrend: [
                    'atr_period',
                    'atr_multiplier',
                    'max_order_amount',
                    'buffer_enabled',
                    'buffer_days',
                    'buffer_mode',
                    'stop_loss_pct',
                    'take_profit_pct'
                ]
            };

            const BASE_EDITABLE_SECTIONS = ['openalgo', 'data', 'backtest', 'ui', 'logging'];

            // --- WebSocket ---
            function setupWebSocket() {
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
                const ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    wsStatus.innerHTML = '<span class="badge bg-success">Connected</span>';
                };

                ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);

                    if (msg.run_id && msg.run_id !== currentRunId) return;

                    switch (msg.type) {
                        case 'status':
                            updateStatus(msg.message);
                            break;
                        case 'progress':
                            updateProgress(msg.data);
                            break;
                        case 'result':
                            updateStatus('Backtest completed.');
                            displayResults(msg.data);
                            runBtn.disabled = false;
                            cancelBtn.style.display = 'none';
                            progressContainer.style.display = 'none';
                            break;
                        case 'cancelled':
                            updateStatus('Backtest cancelled.');
                            alert('Backtest was cancelled successfully.');
                            runBtn.disabled = false;
                            cancelBtn.style.display = 'none';
                            progressContainer.style.display = 'none';
                            break;
                        case 'error':
                            updateStatus(`Error: ${msg.message}`);
                            alert(`Backtest Error: ${msg.message}`);
                            runBtn.disabled = false;
                            cancelBtn.style.display = 'none';
                            progressContainer.style.display = 'none';
                            break;
                    }
                };

                ws.onclose = () => {
                    wsStatus.innerHTML = '<span class="badge bg-danger">Disconnected</span>';
                    // Try to reconnect after 3 seconds
                    setTimeout(setupWebSocket, 3000);
                };

                ws.onerror = () => {
                    wsStatus.innerHTML = '<span class="badge bg-danger">Error</span>';
                };
            }

            // --- UI Updates ---
            function updateStatus(message) {
                statusBar.textContent = message;
            }

            function updateProgress(data) {
                const progressPct = data.progress_pct || 0;
                progressBar.style.width = `${progressPct}%`;
                progressBar.textContent = `${Math.round(progressPct)}%`;
                progressText.textContent = `Processing: ${new Date(data.current_time).toLocaleString()}`;
            }

            function displayResults(result) {
                currentResults = result; // Store results for chart updates
                welcomeMessage.style.display = 'none';
                resultsContainer.style.display = 'block';

                document.getElementById('run-id-display').textContent = result.run_id;

                // Metrics
                const metrics = result.metrics;
                
                // Calculate final portfolio value from equity curve
                const finalEquity = result.equity_curve && result.equity_curve.length > 0 
                    ? result.equity_curve[result.equity_curve.length - 1].equity 
                    : 0;
                
                // Portfolio & Return Metrics
                document.getElementById('metric-final-value').textContent = `â‚¹${finalEquity.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                document.getElementById('metric-initial-capital').textContent = `â‚¹${(metrics.initial_capital || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                document.getElementById('metric-peak-capital').textContent = `â‚¹${(metrics.peak_capital || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                document.getElementById('metric-total-return').textContent = `â‚¹${(metrics.total_return || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                document.getElementById('metric-return').textContent = metrics.total_return_pct.toFixed(2);
                document.getElementById('metric-annualized-return').textContent = metrics.annualized_return ? metrics.annualized_return.toFixed(2) : 'N/A';
                document.getElementById('metric-max-drawdown').textContent = metrics.max_drawdown_pct.toFixed(2);
                document.getElementById('metric-max-drawdown-abs').textContent = `â‚¹${(metrics.max_drawdown || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                
                // Risk Metrics
                document.getElementById('metric-sharpe').textContent = metrics.sharpe_ratio ? metrics.sharpe_ratio.toFixed(3) : 'N/A';
                document.getElementById('metric-sortino').textContent = metrics.sortino_ratio ? metrics.sortino_ratio.toFixed(3) : 'N/A';
                document.getElementById('metric-calmar').textContent = metrics.calmar_ratio ? metrics.calmar_ratio.toFixed(3) : 'N/A';
                document.getElementById('metric-volatility').textContent = metrics.volatility ? (metrics.volatility * 100).toFixed(2) : 'N/A';
                
                // Debug: Log metrics to console
                console.log('Metrics object:', metrics);
                console.log('winning_trades:', metrics.winning_trades);
                console.log('losing_trades:', metrics.losing_trades);
                console.log('largest_win:', metrics.largest_win);
                console.log('largest_loss:', metrics.largest_loss);
                console.log('max_consecutive_wins:', metrics.max_consecutive_wins);
                console.log('max_consecutive_losses:', metrics.max_consecutive_losses);
                
                // Trading Metrics
                document.getElementById('metric-trades').textContent = metrics.total_trades;
                document.getElementById('metric-winning-trades').textContent = metrics.winning_trades || 0;
                document.getElementById('metric-losing-trades').textContent = metrics.losing_trades || 0;
                
                // Show win rate if available, else fallback to metrics.win_rate
                let winRate = null;
                if (result.strategy_state && typeof result.strategy_state.win_rate === 'number') {
                    winRate = result.strategy_state.win_rate;
                } else if (typeof metrics.win_rate === 'number') {
                    winRate = metrics.win_rate;
                }
                document.getElementById('metric-win-rate').textContent = winRate !== null ? winRate.toFixed(1) : 'N/A';
                document.getElementById('metric-profit-factor').textContent = metrics.profit_factor ? metrics.profit_factor.toFixed(2) : 'N/A';
                document.getElementById('metric-avg-trade-pnl').textContent = `â‚¹${(metrics.avg_trade_pnl || 0).toFixed(2)}`;
                document.getElementById('metric-avg-win-pnl').textContent = `â‚¹${(metrics.avg_win_pnl || 0).toFixed(2)}`;
                document.getElementById('metric-avg-loss-pnl').textContent = `â‚¹${(metrics.avg_loss_pnl || 0).toFixed(2)}`;
                document.getElementById('metric-largest-win').textContent = `â‚¹${(metrics.largest_win || 0).toFixed(2)}`;
                document.getElementById('metric-largest-loss').textContent = `â‚¹${(metrics.largest_loss || 0).toFixed(2)}`;
                document.getElementById('metric-max-consecutive-wins').textContent = metrics.max_consecutive_wins || 0;
                document.getElementById('metric-max-consecutive-losses').textContent = metrics.max_consecutive_losses || 0;
                document.getElementById('metric-avg-trade-duration').textContent = metrics.avg_trade_duration ? metrics.avg_trade_duration.toFixed(2) : 'N/A';
                document.getElementById('metric-total-fees').textContent = `â‚¹${(metrics.total_fees || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                
                // Tax Metrics
                document.getElementById('metric-delivery-trades').textContent = metrics.delivery_trades_count || 0;
                document.getElementById('metric-intraday-trades').textContent = metrics.intraday_trades_count || 0;
                document.getElementById('metric-delivery-tax').textContent = `â‚¹${(metrics.total_delivery_tax || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                document.getElementById('metric-intraday-tax').textContent = `â‚¹${(metrics.total_intraday_tax || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                document.getElementById('metric-total-tax').textContent = `â‚¹${(metrics.total_tax_payable || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;

                // Equity Chart
                const equityCurve = result.equity_curve;
                const equityTrace = {
                    x: equityCurve.map(p => p.timestamp),
                    y: equityCurve.map(p => p.equity),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Equity',
                    line: { color: '#00ff88' }
                };
                const equityLayout = {
                    margin: { l: 60, r: 30, t: 30, b: 50 },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    xaxis: { 
                        gridcolor: '#444',
                        title: 'Time'
                    },
                    yaxis: { 
                        gridcolor: '#444',
                        title: 'Equity (â‚¹)'
                    },
                    font: { color: '#fff' },
                    showlegend: false,
                    autosize: true
                };
                Plotly.newPlot('equity-chart', [equityTrace], equityLayout, {responsive: true, displayModeBar: true});

                // Candlestick Chart
                if (result.candles) {
                    const candles = result.candles;
                    
                    // Get selected data points limit
                    const dataPointsSelect = document.getElementById('dataPoints');
                    const maxPointsValue = dataPointsSelect ? dataPointsSelect.value : '200';
                    
                    let limitedCandles;
                    if (maxPointsValue === 'all') {
                        limitedCandles = candles;
                    } else {
                        const maxPoints = parseInt(maxPointsValue);
                        limitedCandles = candles.length > maxPoints ? 
                            candles.slice(-maxPoints) : candles;
                    }

                    const candlestickTrace = {
                        x: limitedCandles.map(c => c.timestamp),
                        open: limitedCandles.map(c => c.open),
                        high: limitedCandles.map(c => c.high),
                        low: limitedCandles.map(c => c.low),
                        close: limitedCandles.map(c => c.close),
                        type: 'candlestick',
                        name: result.symbol || 'Price',
                        increasing: { 
                            line: { color: '#00b894', width: 1},
                            fillcolor: '#00b894'
                        },
                        decreasing: { 
                            line: { color: '#e17055', width: 1},
                            fillcolor: '#e17055'
                        },
                        whiskerwidth: 0.8,
                        xaxis: 'x',
                        yaxis: 'y'
                    };

                    // Add order execution markers if available
                    const traces = [candlestickTrace];
                    
                    if (result.trades && result.trades.length > 0) {
                        // Filter trades to match the limited time range
                        const startTime = limitedCandles.length > 0 ? limitedCandles[0].timestamp : null;
                        const endTime = limitedCandles.length > 0 ? limitedCandles[limitedCandles.length - 1].timestamp : null;
                        
                        const filteredTrades = result.trades.filter(t => {
                            const tradeTime = new Date(t.entry_time);
                            return (!startTime || tradeTime >= new Date(startTime)) && 
                                   (!endTime || tradeTime <= new Date(endTime));
                        });
                        
                        const buyOrders = filteredTrades.filter(t => t.side === 'BUY');
                        const sellOrders = filteredTrades.filter(t => t.side === 'SELL');

                        // Buy order executions
                        if (buyOrders.length > 0) {
                            traces.push({
                                x: buyOrders.map(t => t.entry_time),
                                y: buyOrders.map(t => t.entry_price),
                                mode: 'markers',
                                type: 'scatter',
                                name: 'Buy Executions',
                                marker: {
                                    color: '#00b894',
                                    size: 10,
                                    symbol: 'triangle-up',
                                    line: { color: '#ffffff', width: 1 }
                                }
                            });
                        }

                        // Sell order executions
                        if (sellOrders.length > 0) {
                            traces.push({
                                x: sellOrders.map(t => t.entry_time),
                                y: sellOrders.map(t => t.entry_price),
                                mode: 'markers',
                                type: 'scatter',
                                name: 'Sell Executions',
                                marker: {
                                    color: '#e17055',
                                    size: 10,
                                    symbol: 'triangle-down',
                                    line: { color: '#ffffff', width: 1 }
                                }
                            });
                        }
                    }

                    const candleLayout = {
                        title: {
                            text: `${result.symbol || 'Price'} Chart (${limitedCandles.length} points)`,
                            font: { color: '#fff', size: 16 }
                        },
                        margin: { l: 60, r: 30, t: 60, b: 60 },
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        plot_bgcolor: 'rgba(0,0,0,0)',
                        xaxis: { 
                            gridcolor: '#404040',
                            title: 'Time',
                            rangeslider: { visible: false },
                            type: 'date',
                            automargin: true,
                            tickangle: -45,
                            nticks: 10,
                            color: '#fff'
                        },
                        yaxis: { 
                            gridcolor: '#404040',
                            title: 'Price (â‚¹)',
                            automargin: true,
                            color: '#fff'
                        },
                        font: { color: '#fff', size: 12 },
                        showlegend: true,
                        legend: {
                            x: 0.02,
                            y: 0.98,
                            bgcolor: 'rgba(0,0,0,0.7)',
                            bordercolor: '#404040',
                            borderwidth: 1,
                            font: { color: '#fff', size: 11 }
                        },
                        autosize: true,
                        bargap: 0.1,
                        bargroupgap: 0.05,
                        hovermode: 'x unified'
                    };
                    
                    const candleConfig = {
                        responsive: true, 
                        displayModeBar: true,
                        modeBarButtonsToRemove: ['lasso2d', 'select2d', 'pan2d'],
                        displaylogo: false,
                        scrollZoom: true,
                        doubleClick: 'reset+autosize'
                    };
                    
                    Plotly.newPlot('candle-chart', traces, candleLayout, candleConfig);
                }

                // Order Executions Table
                const tradesTable = document.getElementById('trades-table');
                tradesTable.innerHTML = '';
                result.trades.forEach(trade => {
                    const row = tradesTable.insertRow();
                    const sideClass = trade.side === 'BUY' ? 'text-success' : 'text-danger';
                    const sideText = trade.side;  // Show actual BUY/SELL
                    
                    row.innerHTML = `
                        <td>${new Date(trade.entry_time).toLocaleString()}</td>
                        <td>${new Date(trade.entry_time).toLocaleString()}</td>
                        <td><span class="${sideClass} fw-bold">${sideText}</span></td>
                        <td>${trade.quantity}</td>
                        <td>â‚¹${trade.entry_price.toFixed(2)}</td>
                        <td>â‚¹${trade.entry_price.toFixed(2)}</td>
                        <td><span class="text-info">â‚¹${trade.fees.toFixed(2)}</span></td>
                    `;
                });
            }

            // --- API Calls ---

            function deepCopy(obj) {
                return JSON.parse(JSON.stringify(obj));
            }

            function deepMerge(target, source) {
                if (!source || typeof source !== 'object' || Array.isArray(source)) {
                    return source;
                }

                for (const key in source) {
                    if (!source.hasOwnProperty(key)) continue;
                    const sourceValue = source[key];

                    if (sourceValue && typeof sourceValue === 'object' && !Array.isArray(sourceValue)) {
                        if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key])) {
                            target[key] = {};
                        }
                        deepMerge(target[key], sourceValue);
                    } else {
                        target[key] = sourceValue;
                    }
                }

                return target;
            }

            function getSelectedStrategyType() {
                return strategySelect && strategySelect.value
                    ? strategySelect.value
                    : (loadedConfig?.strategy?.type || 'grid');
            }

            function buildEditableConfig(fullConfig) {
                const strategyType = getSelectedStrategyType();
                const strategyFields = STRATEGY_FIELDS[strategyType] || [];
                const editable = {};

                BASE_EDITABLE_SECTIONS.forEach((section) => {
                    if (fullConfig && fullConfig[section] !== undefined) {
                        editable[section] = deepCopy(fullConfig[section]);
                    }
                });

                const sourceStrategy = fullConfig?.strategy || {};
                const strategy = { type: strategyType };
                strategyFields.forEach((field) => {
                    if (sourceStrategy[field] !== undefined) {
                        strategy[field] = sourceStrategy[field];
                    }
                });
                editable.strategy = strategy;

                return editable;
            }

            // Helper: Recursively create form fields for config object
            function createConfigFields(obj, parentKey = '') {
                let html = '';
                for (const key in obj) {
                    if (!obj.hasOwnProperty(key)) continue;
                    const value = obj[key];
                    const fieldId = parentKey ? `${parentKey}.${key}` : key;
                    if (fieldId === 'strategy.type') continue;
                    const label = `<label class="form-label fw-bold mt-2" for="${fieldId}">${fieldId.replace(/\./g, ' > ')}</label>`;
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        html += `<fieldset class="border rounded p-2 mb-2"><legend class="fs-6">${fieldId}</legend>`;
                        html += createConfigFields(value, fieldId);
                        html += `</fieldset>`;
                    } else {
                        let inputType = 'text';
                        let step = '';
                        if (typeof value === 'number') {
                            inputType = 'number';
                            step = 'step="any"';
                        } else if (typeof value === 'boolean') {
                            inputType = 'checkbox';
                        }
                        html += `<div class="mb-2">${label}`;
                        if (inputType === 'checkbox') {
                            html += `<input type="checkbox" class="form-check-input ms-2" id="${fieldId}" name="${fieldId}" ${value ? 'checked' : ''}>`;
                        } else {
                            html += `<input type="${inputType}" class="form-control" id="${fieldId}" name="${fieldId}" value="${inputType === 'number' ? value : String(value).replace(/"/g, '&quot;')}" ${step}>`;
                        }
                        html += `</div>`;
                    }
                }
                return html;
            }

            // Helper: Set form fields from config object
            function setFormFields(obj, parentKey = '') {
                for (const key in obj) {
                    if (!obj.hasOwnProperty(key)) continue;
                    const value = obj[key];
                    const fieldId = parentKey ? `${parentKey}.${key}` : key;
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        setFormFields(value, fieldId);
                    } else {
                        const input = document.getElementById(fieldId);
                        if (input) {
                            if (input.type === 'checkbox') {
                                input.checked = !!value;
                            } else {
                                input.value = value;
                            }
                        }
                    }
                }
            }

            // Helper: Get config object from form fields
            function getFormConfig(obj, parentKey = '') {
                const result = Array.isArray(obj) ? [] : {};
                for (const key in obj) {
                    if (!obj.hasOwnProperty(key)) continue;
                    const value = obj[key];
                    const fieldId = parentKey ? `${parentKey}.${key}` : key;
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        result[key] = getFormConfig(value, fieldId);
                    } else {
                        const input = document.getElementById(fieldId);
                        if (input) {
                            if (input.type === 'checkbox') {
                                result[key] = input.checked;
                            } else if (input.type === 'number') {
                                result[key] = input.value === '' ? null : Number(input.value);
                            } else {
                                result[key] = input.value;
                            }
                        } else {
                            result[key] = value;
                        }
                    }
                }
                return result;
            }

            function renderConfigForm() {
                if (!loadedConfig) return;
                const editableConfig = buildEditableConfig(loadedConfig);
                configFields.innerHTML = createConfigFields(editableConfig);
                setFormFields(editableConfig);
            }

            function renderStrategyDropdown() {
                if (!strategySelect) return;
                strategySelect.innerHTML = '';

                availableStrategies.forEach((strategy) => {
                    const option = document.createElement('option');
                    option.value = strategy.id;
                    option.textContent = strategy.label;
                    option.dataset.configPath = strategy.config_path;
                    strategySelect.appendChild(option);
                });

                const currentType = loadedConfig?.strategy?.type;
                const hasCurrent = availableStrategies.some((item) => item.id === currentType);

                if (hasCurrent) {
                    strategySelect.value = currentType;
                } else if (availableStrategies.length > 0) {
                    strategySelect.value = availableStrategies[0].id;
                }

                updateStrategyPathHint();
            }

            function updateStrategyPathHint() {
                if (!strategyConfigPath || !strategySelect) return;
                const option = strategySelect.options[strategySelect.selectedIndex];
                const path = option?.dataset?.configPath || '';
                strategyConfigPath.textContent = path ? `Config file: ${path}` : '';
            }

            async function loadStrategies() {
                try {
                    const response = await fetch('/api/strategies');
                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to load strategy catalog');
                    }
                    availableStrategies = Array.isArray(data.strategies) ? data.strategies : [];
                } catch (e) {
                    console.error('Failed to load strategy catalog', e);
                    availableStrategies = [
                        { id: 'grid', label: 'Grid', config_path: 'configs/active/config.yaml' },
                        { id: 'supertrend', label: 'Supertrend', config_path: 'configs/active/config-supertrend.yaml' }
                    ];
                }
            }

            async function loadConfig() {
                try {
                    const response = await fetch('/api/config');
                    const config = await response.json();
                    if (!response.ok) {
                        throw new Error(config.error || 'Failed to load configuration');
                    }
                    loadedConfig = config;
                    renderStrategyDropdown();
                    if (strategySelect?.value) {
                        loadedConfig.strategy.type = strategySelect.value;
                    }
                    renderConfigForm();
                } catch (e) {
                    console.error("Failed to load config", e);
                    alert("Failed to load configuration.");
                }
            }

            async function saveConfig() {
                try {
                    if (!loadedConfig) throw new Error('Config not loaded');

                    const editableConfig = buildEditableConfig(loadedConfig);
                    const updatedVisibleConfig = getFormConfig(editableConfig);
                    const config = deepMerge(deepCopy(loadedConfig), updatedVisibleConfig);
                    config.strategy.type = getSelectedStrategyType();

                    const response = await fetch('/api/config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(config)
                    });
                    if (response.ok) {
                        loadedConfig = config;
                        updateStatus('Configuration saved.');
                    } else {
                        const error = await response.json();
                        throw new Error(error.error || 'Unknown error');
                    }
                } catch (e) {
                    console.error("Failed to save config", e);
                    alert(`Failed to save configuration: ${e.message}`);
                }
            }

            async function runBacktest() {
                runBtn.disabled = true;
                cancelBtn.style.display = 'block';
                updateStatus('Starting backtest...');
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressBar.textContent = '';
                progressText.textContent = 'Initiating...';
                welcomeMessage.style.display = 'none';
                resultsContainer.style.display = 'none';

                try {
                    // First, save the current config
                    await saveConfig();

                    const response = await fetch('/api/backtest/run', { method: 'POST' });
                    if (response.status === 202) {
                        const data = await response.json();
                        currentRunId = data.run_id;
                        updateStatus(`Backtest started with Run ID: ${currentRunId}`);
                        document.getElementById('run-id-display').textContent = currentRunId;
                    } else {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to start backtest');
                    }
                } catch (e) {
                    console.error("Failed to run backtest", e);
                    alert(`Failed to run backtest: ${e.message}`);
                    runBtn.disabled = false;
                    cancelBtn.style.display = 'none';
                    progressContainer.style.display = 'none';
                }
            }

            async function cancelBacktest() {
                if (!currentRunId) {
                    alert('No active backtest to cancel.');
                    return;
                }

                try {
                    cancelBtn.disabled = true;
                    updateStatus('Cancelling backtest...');
                    
                    const response = await fetch(`/api/backtest/${currentRunId}/cancel`, { method: 'POST' });
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Cancel request sent:', data.message);
                    } else {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to cancel backtest');
                    }
                } catch (e) {
                    console.error("Failed to cancel backtest", e);
                    alert(`Failed to cancel backtest: ${e.message}`);
                    cancelBtn.disabled = false;
                }
            }

            // --- Event Listeners ---
            runBtn.addEventListener('click', runBacktest);
            cancelBtn.addEventListener('click', cancelBacktest);

            if (configForm) {
                configForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    saveConfig();
                });
            }

            if (strategySelect) {
                strategySelect.addEventListener('change', function() {
                    if (loadedConfig?.strategy) {
                        loadedConfig.strategy.type = strategySelect.value;
                    }
                    updateStrategyPathHint();
                    renderConfigForm();
                });
            }
            
            // Chart update functionality
            const updateChartBtn = document.getElementById('updateChart');
            if (updateChartBtn) {
                updateChartBtn.addEventListener('click', function() {
                    if (currentResults) {
                        // Re-render the candlestick chart with new settings
                        console.log('Updating chart with new data point settings');
                        displayResults(currentResults);
                    } else {
                        alert('No backtest results available. Please run a backtest first.');
                    }
                });
            }

            // --- Initial Load ---
            loadStrategies().then(loadConfig);
            setupWebSocket();
        });
    </script>
</body>
</html>